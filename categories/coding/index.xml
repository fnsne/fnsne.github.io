<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Coding on fnsne&#39;s coding world</title>
        <link>https://coding.fnsne.com/categories/coding/</link>
        <description>Recent content in Coding on fnsne&#39;s coding world</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-TW</language>
        <copyright>fnsne</copyright>
        <lastBuildDate>Thu, 20 Feb 2025 22:02:49 +0800</lastBuildDate><atom:link href="https://coding.fnsne.com/categories/coding/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>英文不好的我_如何在1個月理解國外團隊維護的產品</title>
        <link>https://coding.fnsne.com/posts/how-i-fast-understand-new-project/</link>
        <pubDate>Thu, 20 Feb 2025 22:02:49 +0800</pubDate>
        
        <guid>https://coding.fnsne.com/posts/how-i-fast-understand-new-project/</guid>
        <description>&lt;p&gt;到現在，換新工作一段時間了，來分享一下，我是如何適應並且慢慢理解產品是怎麼寫的
主要就兩個步驟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分析並假設&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驗證，獲得回饋&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分析並假設&#34;&gt;分析並假設
&lt;/h2&gt;&lt;p&gt;我是用heptabase的白板來分析的&lt;/p&gt;
&lt;p&gt;流程簡單來說，就是去讀code，然後：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立理解的骨架&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;遇到「名詞」、「模組」、「function」、「class」的時候，&lt;/p&gt;
&lt;p&gt;就建立一張卡片，&lt;/p&gt;
&lt;p&gt;一張標題為那個東西的卡片，&lt;/p&gt;
&lt;p&gt;並寫上我目前對它的理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;填充新發現的理解&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在每次靈感來臨、&lt;/p&gt;
&lt;p&gt;突然理解某個東西的時候，&lt;/p&gt;
&lt;p&gt;就到對應的那張卡片上面做筆記。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就這樣，分析的部分就這麼簡單，但對於初步理解很好用。&lt;/p&gt;
&lt;h2 id=&#34;驗證獲得回饋&#34;&gt;驗證，獲得回饋
&lt;/h2&gt;&lt;p&gt;也很簡單，就是每次找到小發現後，就&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;趕快去code的其他地方，驗證看看我的理解是否正確。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;詢問國外同事，我的理解是否正確。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;嘗試接一些和小發現相關的任務，像我就膽大的接了一張明顯很複雜的重構單。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（雖然我還沒處理完，但很明顯的，在研究分析並重構這份code的時候，我理解到了非常多這個產品相關的內容。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;就這樣，我藉由這套方法，讓我在沒有太大心理阻力，並且要和國外同事用英文溝通的情況下，快速理解產品的內容，還有要怎麼寫。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我真的覺得接了一張複雜重構單，是我一個進公司以來做過最正確的一件事。&lt;/p&gt;
&lt;p&gt;反正即使失敗，我也獲得了失敗的經驗，&lt;/p&gt;
&lt;p&gt;這些經驗會化為未來成功的踏腳石。&lt;/p&gt;
&lt;p&gt;所有的嘗試都是有意義的，&lt;/p&gt;
&lt;p&gt;他們會在未來給予我們幫助，&lt;/p&gt;
&lt;p&gt;所以要多嘗試、並且紀錄下來。&lt;/p&gt;
&lt;p&gt;P.S. 感謝現在有ChatGPT的存在，讓我的英文能以更好讀的形式發出去。不然我連問問題可能都很難溝通啊。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>淺談在Golang上面的物件導向</title>
        <link>https://coding.fnsne.com/posts/golang_object_oriented/</link>
        <pubDate>Tue, 02 Aug 2022 20:01:59 +0800</pubDate>
        
        <guid>https://coding.fnsne.com/posts/golang_object_oriented/</guid>
        <description>&lt;p&gt;從物件導向的語言轉到Golang常常會遇到，不知道該怎麼在Golang實作類似多型和繼承的功能。這是因為Golang根本不是物件導向的語言。&lt;/p&gt;
&lt;p&gt;在網路上會看到一些文章，寫說可以使用可以embed來模擬繼承，但事實上embed的用途應該只是用來減少重複的程式碼，增加可讀性。像在io package裡面就很明顯，如interface ReadWriter就是用Reader和Writer 兩個interface組合起來的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ReadWriter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Reader&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;Writer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用embed struct的方式來模擬繼承。為了要可以被抽換注入，還是得要同時implement一個interface。這樣還不如直接implement interface就好了。&lt;/p&gt;
&lt;p&gt;在Golang，唯一類似物件導向的東西只有 interface。只要有implement interface，就可以在宣告使用這個interface的地方使用。&lt;/p&gt;
&lt;p&gt;個人的理解，Golang把繼承的概念且分成兩個部分：embed和interface。embed struct (interface) 負責擴增fields (method); interface負責讓不同struct可以有相同的調用方式&lt;/p&gt;
&lt;p&gt;embed struct 的功能只是單純消除struct的field的重用而已。embed interface 也是如此，單純想要減少 method 裡面重複宣告 method 的程式碼。&lt;/p&gt;
&lt;p&gt;簡單來說，就是&lt;/p&gt;
&lt;p&gt;想要可以抽換，用interface; 想要減少重複可以用embed的方式包裝組合&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
