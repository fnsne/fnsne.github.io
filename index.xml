<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>fnsne&#39;s coding world</title>
        <link>http://coding.fnsne.com/</link>
        <description>Recent content on fnsne&#39;s coding world</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-TW</language>
        <copyright>fnsne</copyright>
        <lastBuildDate>Fri, 02 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://coding.fnsne.com/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Archives</title>
        <link>http://coding.fnsne.com/page/archives/</link>
        <pubDate>Fri, 02 Aug 2024 00:00:00 +0000</pubDate>
        
        <guid>http://coding.fnsne.com/page/archives/</guid>
        <description></description>
        </item>
        <item>
        <title>如何用certbot申請 Let’s Encrypt 的憑證</title>
        <link>http://coding.fnsne.com/posts/2024-07-04/%E7%94%A8certbot%E7%94%B3%E8%AB%8B%E6%86%91%E8%AD%89/</link>
        <pubDate>Thu, 04 Jul 2024 21:09:08 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2024-07-04/%E7%94%A8certbot%E7%94%B3%E8%AB%8B%E6%86%91%E8%AD%89/</guid>
        <description>&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝certbot&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install certbot
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用certbot申請SSL憑證&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo certbot certonly -d &amp;lt;DOMAINNAME&amp;gt; --manual
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;certonly&lt;/code&gt;：表示只需要申請憑證即可。certbot還有支援一些常見的server替換SSL的功能，如apache、nginx等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--manual&lt;/code&gt;：表示要使用互動界面來申請憑證。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：使用&amp;ndash;manual的方式申請的憑證，除非有配合使用其它驗證插件，否則無法自動renew。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這個方式申請的憑證有提供兩種預設方式驗證&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;會產生一個challenge檔案，然後讓我們放到要使用這個憑證的機器（至少是這個domain name會連到的機器）的根目錄下指定的資料夾，讓ACME驗證可以使用申請的domain name加上給定的ACME資料夾，拿到申請的檔案。&lt;/li&gt;
&lt;li&gt;直接會在目標機器上加上一個短暫的server，做到在指定的網址回傳上述的challenge檔案。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外certbot其實還提供了其它的驗證方式，例如DNS&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-azure&#34; data-lang=&#34;azure&#34;&gt;sudo certbot certonly -d &amp;lt;DOMAINNAME&amp;gt; --preferred-challenges dns --manual
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;certbot會在申請的互動界面，產生一個申請憑證網域的challenge key和value，申請人要到DNS託管服務，例如GoDaddy、AWS Route53等服務上，對要申請憑證的網域使用certbot產出的key value來建立一筆TXT設定，讓Let’s Encrypt確定要申請的網域是屬於你的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用route53插件驗證&#34;&gt;使用Route53插件驗證
&lt;/h2&gt;&lt;p&gt;其實就是藉由Route53的API，讓插件替我們做完把ACME Chellenge TXT設定到DNS Server上的這段流程。所以需要設定AWS的access client到申請憑證的機器上。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝certbot-dns-route53&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt install python3-certbot-dns-route53
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;其它plugin的名稱也是使用相同的pattern: &lt;code&gt;python3-certbot-dns-&amp;lt;PLUGIN&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設定AWS的access client&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;到AWS設定一個Policy&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Version&amp;#34;&lt;/span&gt;:&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2012-10-17&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Id&amp;#34;: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;certbot-dns-route53 sample policy&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Statement&amp;#34;: &lt;/span&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Effect&amp;#34;: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Allow&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Action&amp;#34;: &lt;/span&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;route53:ListHostedZones&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;route53:GetChange&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;Resource&amp;#34;: &lt;/span&gt;[
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Effect&amp;#34;&lt;/span&gt; : &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Allow&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Action&amp;#34;&lt;/span&gt; : [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;route53:ChangeResourceRecordSets&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Resource&amp;#34;&lt;/span&gt; : [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;arn:aws:route53:::hostedzone/YOURHOSTEDZONEID&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Version&lt;/code&gt;的值不能改，這是告訴AWS要用這版的規則來看這個Policy&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;YOURHOSTEDZONEID&lt;/code&gt;：去Route53點選要設定的domain name，就會寫出它的host zone ID（託管區域ID）了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立一個IAM account，並且授予它上面的policy權限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在要執行certbot的機器上建立一個config檔，叫~/.aws/config內容如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[default]
aws_access_key_id=&amp;lt;IAM的ID&amp;gt;
aws_secret_access_key=&amp;lt;IAM的secret key&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意，如果執行certbot需要使用sudo來執行，這個config必須改放到&lt;code&gt;/root/.aws/config&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;執行certbot&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo certbot certonly --dns-route53 -d rd2.team.araliadata.io
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果有要申請wildcard網域，需要多加上*.rd2.team.araliadata.io才需要有這段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;—-post-hook&lt;/code&gt;：當certbot完成執行後，會在本地執行的動作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設定排程執行&lt;code&gt;sudo certbot renew&lt;/code&gt;，它會自行檢查是否有憑證快要到期了，如果快要到期才會真的再次申請新的憑證下來。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo certbot renew --cert-name &amp;lt;憑證名稱&amp;gt; --post-hook &amp;#34;docker compose -f /home/bigobject/data-planet-testbed/ambrose/docker-compose.yml down &amp;amp; /home/bigobject/data-planet-testbed/ambrose/docker-compose.yml up -d&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;憑證名稱：可以使用certbot certificates來查看&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;certbot renew&lt;/code&gt;：當憑證會在30天內到期時，真的去申請新的憑證，還未到期不會真的去申請新的憑證。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ex: 每週一檢查一次&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#sudo crontab -e
0 0 * * 1 sudo certbot renew --cert-name rd2.team.araliadata.io --post-hook &amp;#34;docker compose -f /home/bigobject/data-planet-testbed/ambrose/docker-compose.yml down &amp;amp; /home/bigobject/data-planet-testbed/ambrose/docker-compose.yml up -d&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;提醒&#34;&gt;提醒
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以先加上 &lt;code&gt;--dry-run&lt;/code&gt; ，用來測試server申請憑證是否能成功，以防操作太多次，超過額度，不給申請。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;--manual&lt;/code&gt;的憑證申請，不能使用renew功能，除非有加上authentication hook，例如上面提到的route-53 plugin。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;route-53 plugin其實就是用script連到route-53服務，新增對應的ACME challenge TXT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ACME的驗證（&lt;code&gt;--preferred-challenges&lt;/code&gt;），如果選擇使用DNS的方式驗證，需要使用&lt;code&gt;--manual&lt;/code&gt;才能做。除非加上DNS插件驗證（如route53）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>在乾淨環境建立k8s環境</title>
        <link>http://coding.fnsne.com/posts/d-%E5%9C%A8%E4%B9%BE%E6%B7%A8%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8Bk8s%E7%92%B0%E5%A2%83/</link>
        <pubDate>Thu, 29 Jun 2023 09:34:49 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/d-%E5%9C%A8%E4%B9%BE%E6%B7%A8%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8Bk8s%E7%92%B0%E5%A2%83/</guid>
        <description>&lt;h1 id=&#34;在乾淨環境建立k8s環境&#34;&gt;在乾淨環境建立k8s環境
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;使用k8sadmin架設k8s環境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;linux環境設定&#34;&gt;linux環境設定
&lt;/h2&gt;&lt;p&gt;在開始安裝之前，需要先把host給設定好，所以會先說明要做哪些動作。&lt;/p&gt;
&lt;h3 id=&#34;關閉swap功能&#34;&gt;關閉swap功能
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;關閉swap&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;swapoff -a
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;編輯 &lt;code&gt;/etc/fstab&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim /etc/fstab
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把檔案裡面 &lt;code&gt;/swapfile &lt;/code&gt;開頭的這行註解掉&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/d-%E5%9C%A8%E4%B9%BE%E6%B7%A8%E7%92%B0%E5%A2%83%E5%BB%BA%E7%AB%8Bk8s%E7%92%B0%E5%A2%83/edit-swap.png&#34;&gt;&lt;figcaption&gt;
         &lt;h4&gt;編輯swap的畫面.png&lt;/h4&gt;
       &lt;/figcaption&gt;
   &lt;/figure&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;安裝docker&#34;&gt;安裝docker
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;安裝所需的工具&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!shell&#34; data-lang=&#34;!shell&#34;&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install ca-certificates curl gnupg lsb-release
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下載docker並新增官方的GPG key&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!shell&#34; data-lang=&#34;!shell&#34;&gt;sudo mkdir -m 0755 -p /etc/apt/keyrings &amp;amp;&amp;amp; curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;設定放docker的repository&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!shell&#34; data-lang=&#34;!shell&#34;&gt;echo &amp;#34;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&amp;#34; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝docker engine&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!javascript&#34; data-lang=&#34;!javascript&#34;&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;測試有沒有成功安裝docker engine&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;調整權限，這樣以後就不需要每個docker command前面還要加sudo了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo usermod -aG docker $USER
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;安裝apt-transport-httpsca-certificatescurl&#34;&gt;安裝apt-transport-https、ca-certificates、curl
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!shell&#34; data-lang=&#34;!shell&#34;&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sudo&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;apt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;install&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;apt&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;transport&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;https&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ca&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;certificates&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;curl&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;加上-kubernetes-apt-的repo&#34;&gt;加上 Kubernetes &lt;code&gt;apt&lt;/code&gt; 的repo
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下載google cloud public signing key&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!shell&#34; data-lang=&#34;!shell&#34;&gt;sudo curl -fsSLo /etc/apt/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加上 &lt;code&gt;apt&lt;/code&gt; 的repo&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&amp;#34;&lt;/span&gt; | sudo tee /etc/apt/sources.list.d/kubernetes.list
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;安裝k8s環境執行用的工具&#34;&gt;安裝k8s環境執行用的工具
&lt;/h2&gt;&lt;h3 id=&#34;更新apt並安裝kubeadm-kubectl-kubelet並鎖定版本&#34;&gt;更新apt並安裝kubeadm, kubectl, kubelet，並鎖定版本
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!shell&#34; data-lang=&#34;!shell&#34;&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install -y kubelet kubeadm kubectl &amp;amp;&amp;amp; sudo apt-mark hold kubelet kubeadm kubectl
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;安裝cri-dockerd&#34;&gt;安裝cri-dockerd
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Container Runtime Interface (CRI)：Kubelet會使用CRI 界面來建立container。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;到cri-dockerd的&lt;a class=&#34;link&#34; href=&#34;https://github.com/Mirantis/cri-dockerd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;repo&lt;/a&gt;上面，release找到對應的版本。複製下載鏈接，使用wget在機器上面下載下來&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;例如ubuntu的&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!javascript&#34; data-lang=&#34;!javascript&#34;&gt;wget https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.1/cri-dockerd_0.3.1.3-0.ubuntu-jammy_amd64.deb 
sudo dpkg -i cri-dockerd_0.3.1.3-0.ubuntu-jammy_amd64.deb
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;檢查有沒有安裝成功並跑起來&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;sudo&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;systemctl&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;status&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cri&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;docker&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;socket&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;啟動k8s-cluster&#34;&gt;啟動k8s cluster
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;如果有需要的話，可以使用&lt;code&gt;kubeadm init -h&lt;/code&gt;看看，上面有更多資訊可以看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用kubeadm建立cluster&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo kubeadm init {options}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;options常用的有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--pod-network-cidr&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;希望給pod的網段例如：10.244.0.0/16&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要注意，如果和要使用的CNI的預設不一樣，到時候得要在CNI上面設定一下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--apiserver-advertise-address&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;來指定api server的網址，如果沒有設定，會使用預設的$網路$ 界面。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--apiserver-bind-port&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;apiserver的port，預設是6443&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-apiserver-bind-port int32     Default: 6443Port for the API Server to bind to. (&lt;a class=&#34;link&#34; href=&#34;https://read.readwise.io/read/01gz07qkqeenq6zpg7adj1agf2&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;View Source&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--service-cidr&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;來指定service到時候被產生出來的virtual ip的range&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用&lt;code&gt;--cri-socket={CRI的socket}&lt;/code&gt;指定特定的cri&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!javascript&#34; data-lang=&#34;!javascript&#34;&gt;sudo kubeadm init --pod-network-cidr 192.167.0.0/16 --cri-socket unix:/var/run/cri-dockerd.sock --service-cidr 192.168.192.0/18
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;做錯了可以使用kubeadm reset來關閉剛剛啟動（或者失敗）的k8s cluster。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最後為了讓現在的帳號可以使用kubectl，而不是使用root帳號，需要做以下的操作&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!javascript&#34; data-lang=&#34;!javascript&#34;&gt;mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;安裝cni&#34;&gt;安裝CNI
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Container Network Interface(CNI)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;負責container之間、還有對外的各種溝通&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;負責創建、回收container時，用到的Network的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常見的CNI有&lt;code&gt;Flannel&lt;/code&gt;(已停止維護)、&lt;code&gt;Calico&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安裝Flannel的方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-!javascript&#34; data-lang=&#34;!javascript&#34;&gt;kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml 
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝Calico的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;下載yaml檔&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wget https://raw.githubusercontent.com/projectcalico/calico/v3.24.1/manifests/calico.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安裝並啟動&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;kubectl&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calico&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;yaml&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;以上就完成了在Linux上架好一個k8s環境的controller plane (k8s叢集的master)了。但是這個時候還沒辦法在k8s環境裡面，在預設的情況下，controller plane所在的host會有設定一個汙點（類似tag的東西），不讓任何非系統運行是所需的Pod（k8s運行的基本單位）被啟動起來。所以還需要再把其它機器加進來k8s cluster中，才能正常運作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;把其它臺機器加入這個k8s-cluster&#34;&gt;把其它臺機器加入這個k8s cluster
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和controller prlane一樣，也要先設定好環境：&lt;a class=&#34;link&#34; href=&#34;#linux%e7%92%b0%e5%a2%83%e8%a8%ad%e5%ae%9a&#34; &gt;linux環境設定&lt;/a&gt;和&lt;a class=&#34;link&#34; href=&#34;#%e5%ae%89%e8%a3%9dk8s%e7%92%b0%e5%a2%83%e5%9f%b7%e8%a1%8c%e7%94%a8%e7%9a%84%e5%b7%a5%e5%85%b7&#34; &gt;安裝k8s環境執行用的工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用上面在建立cluster時，最後在畫面上顯示的join命令。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;kubeadm&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;koin&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;token&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;cluster產生的token&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要注意的是，token只有24小時的有效期限。過期了需要回到controller plane產生新的token&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubeadm token create --print-join-command
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Local Path Provisioner</title>
        <link>http://coding.fnsne.com/posts/2023-04-27/local-path-provisioner/</link>
        <pubDate>Thu, 27 Apr 2023 09:30:27 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2023-04-27/local-path-provisioner/</guid>
        <description>&lt;h1 id=&#34;local-path-provisioner&#34;&gt;Local Path Provisioner
&lt;/h1&gt;&lt;p&gt;是一個 &lt;code&gt;Container Storage Interface (CSI)&lt;/code&gt;，也就是用來提供k8s環境下建立&lt;code&gt;Persistent Volume (PV)&lt;/code&gt;的插件&lt;/p&gt;
&lt;h2 id=&#34;安裝&#34;&gt;安裝
&lt;/h2&gt;&lt;p&gt;command&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.24/deploy/local-path-storage.yaml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;會建立&lt;code&gt;local-path-storage&lt;/code&gt;這個namespace，要查看運行狀態，可以到裡面看log&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt; kubectl -n local-path-storage logs pods/local-path-provisioner-7f8667b75c-hjrrb
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;使用configmap來給予設定&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;ConfigMap&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;v1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;local-path-config&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;namespace&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;local-path-storage&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;data&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;config.json&lt;/span&gt;: |-&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                &amp;#34;nodePathMap&amp;#34;:[
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                        &amp;#34;node&amp;#34;:&amp;#34;DEFAULT_PATH_FOR_NON_LISTED_NODES&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                        &amp;#34;paths&amp;#34;:[&amp;#34;/opt/local-path-provisioner&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                },
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                        &amp;#34;node&amp;#34;:&amp;#34;yasker-lp-dev1&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                        &amp;#34;paths&amp;#34;:[&amp;#34;/opt/local-path-provisioner&amp;#34;, &amp;#34;/data1&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                },
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                {
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                        &amp;#34;node&amp;#34;:&amp;#34;yasker-lp-dev3&amp;#34;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                        &amp;#34;paths&amp;#34;:[]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                ]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        }&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;setup&lt;/span&gt;: |-&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        #!/bin/sh
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        set -eu
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        mkdir -m 0777 -p &amp;#34;$VOL_DIR&amp;#34;&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;teardown&lt;/span&gt;: |-&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        #!/bin/sh
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        set -eu
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        rm -rf &amp;#34;$VOL_DIR&amp;#34;&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;helperPod.yaml&lt;/span&gt;: |-&lt;span style=&#34;color:#e6db74&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        apiVersion: v1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        kind: Pod
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        metadata:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          name: helper-pod
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        spec:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          containers:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;          - name: helper-pod
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            image: busybox&lt;/span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;config.json說明
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nodePathMap&lt;/code&gt;：用來表示在各自的Node上，存資料的位置，規則如下
&lt;ul&gt;
&lt;li&gt;沒有設定path的node會套用&lt;code&gt;DEFAULT_PATH_FOR_NON_LISTED_NODES&lt;/code&gt;的設定&lt;/li&gt;
&lt;li&gt;如果有列出來，但path是空的，代表這個Node不會允許用local-path-provisioner來建pv&lt;/li&gt;
&lt;li&gt;每個node的path可以給好幾個位置，當裡面超過一個位置，每次建的時候會隨機選一個來用。&lt;/li&gt;
&lt;li&gt;path一定要是絕對路徑&lt;/li&gt;
&lt;li&gt;在同個node裡面，同一個path不能重複列。&lt;/li&gt;
&lt;li&gt;同一個node不能重複列出來。&lt;/li&gt;
&lt;li&gt;不允許使用&lt;code&gt;/&lt;/code&gt; 根目錄&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sharedFileSystemPath&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;假如有一個file system有被mount在所有的Node上時，可以使用這個設定來指定，指定都用同一個位置。&lt;/li&gt;
&lt;li&gt;和nodePathMap互斥，所以當有使用&lt;code&gt;sharedFileSystemPath&lt;/code&gt;時，&lt;code&gt;nodePathMap&lt;/code&gt;一定要是&lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;只有使用了&lt;code&gt;sharedFileSystemPath&lt;/code&gt;時，才會支援&lt;code&gt;ReadOnlyMany&lt;/code&gt;、&lt;code&gt;ReadWriteMany&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setup&lt;/code&gt;: 每個volume在建立之前會先做的script，用來準備node上volume資料夾用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;teardown&lt;/code&gt;：每個volume在被刪掉後會做的script，用來清掉node上volume資料夾用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;helperPod.yaml&lt;/code&gt;：用來執行setup和teardown的pod template&lt;/li&gt;
&lt;li&gt;setup和teardown上面可以使用的環境變數：
&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;環境變數&lt;/th&gt;
&lt;th&gt;說明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;VOL_DIR&lt;/td&gt;
&lt;td&gt;放置volume的路徑（nodePath寫的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VOL_MODE&lt;/td&gt;
&lt;td&gt;The PersistentVolume mode (Block or Filesystem).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VOL_SIZE_BYTES&lt;/td&gt;
&lt;td&gt;Requested volume size in bytes.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;設定storageclass來驅動local-path-provisioner&#34;&gt;設定storageClass來驅動local-path-provisioner
&lt;/h2&gt;&lt;p&gt;provisioner欄位，官方Github寫的&lt;code&gt;cluster.local/local-path-provisioner&lt;/code&gt;沒有用，反而要用rancher.io/local-path才有用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;apiVersion&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;storage.k8s.io/v1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;kind&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;StorageClass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;metadata&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;incloud-lvm&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;provisioner&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;rancher.io/local-path &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;volumeBindingMode&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;WaitForFirstConsumer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;reclaimPolicy&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;Retain&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>關於鎖</title>
        <link>http://coding.fnsne.com/posts/2022-09-20/%E9%97%9C%E6%96%BC%E9%8E%96/</link>
        <pubDate>Tue, 20 Sep 2022 16:35:44 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-09-20/%E9%97%9C%E6%96%BC%E9%8E%96/</guid>
        <description>&lt;h1 id=&#34;關於鎖lock&#34;&gt;關於鎖(lock)
&lt;/h1&gt;&lt;p&gt;畢業後，太久沒有用到相關的東西，概念開始有點混淆了，所以拿出恐龍本讀回來。順便做一篇筆記&lt;/p&gt;
&lt;h2 id=&#34;一些專有名詞&#34;&gt;一些專有名詞
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名稱&lt;/th&gt;
&lt;th&gt;說明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cooperation process （協作行程）&lt;/td&gt;
&lt;td&gt;會操作到共同資源的不同process&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;critical section&lt;/td&gt;
&lt;td&gt;在各種cooperation process 裡面會操作到共同資源的code區塊&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;鎖想解決的問題&#34;&gt;鎖想解決的問題
&lt;/h2&gt;&lt;p&gt;在多核心多執行序問世之前的單核心的時代，是一個核心切換來切換去的做不同事，在時間區間上每個時間點都只有一個process正在被cpu執行，如下圖。&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-20/%E9%97%9C%E6%96%BC%E9%8E%96/single-core.jpg&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;單核心運作示意圖&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;而在多核心問世以後開始會出現一些問題，如下圖。&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-20/%E9%97%9C%E6%96%BC%E9%8E%96/multi-core.jpg&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;多核心的運作示意圖&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;開始會發生圖上，兩個核心會同時執行不同的process ，這個時候可能會發生互相改到資料的問題。例如process B和D是要在印表機上面印出現在電腦的時間，就有可能會發生一下的輸出：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假設兩個核心在執行processB和D的時間點是&lt;code&gt;15:38&lt;/code&gt;和&lt;code&gt;15:40&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;15:153:840
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這是因為兩個核心互相搶著輸出到印表機，但是順序亂掉的緣故。為了解決這個問題，鎖的概念被提了出來。&lt;/p&gt;
&lt;h2 id=&#34;鎖的用途&#34;&gt;鎖的用途
&lt;/h2&gt;&lt;p&gt;用來保護注critical section（以上面的例子來看，是Process B和Process D裡面，執行輸出資料到印表機的code block）。強制這兩個critical section，在同一個時間裡面，頂多只能有一個執行，另一個想要執行，得要等到另一個結束後，才能開始動作。&lt;/p&gt;
&lt;h2 id=&#34;鎖的種類&#34;&gt;鎖的種類
&lt;/h2&gt;&lt;h3 id=&#34;mutex-lock互斥鎖&#34;&gt;mutex lock（互斥鎖）
&lt;/h3&gt;&lt;p&gt;又稱自旋鎖，會讓這個process一直卡在loop裡面，直到能夠存取資料後，才跳出迴圈，開始執行這個critical section。&lt;/p&gt;
&lt;p&gt;因為實際上是一直在執行loop的狀態下做等待資源釋放的，所以它不需要使用到context switch，在獲得資源後的切換速度很快。所以常常被使用在共用資源都只會被佔用短短時間的情境下使用。&lt;/p&gt;
&lt;p&gt;mutex lock的概念是一個被相同mutex lock保護起來的多個critical section，一個時間裡只能有一個被執行，其他都得要等待它mutex lock釋放後，才能繼續搶，搶到的才能執行。&lt;/p&gt;
&lt;h3 id=&#34;semaphore-lock號誌鎖&#34;&gt;semaphore lock（號誌鎖）
&lt;/h3&gt;&lt;p&gt;和mutex lock不同，可以設定資源同一時間下，最多可以有&lt;code&gt;S&lt;/code&gt;個process同時執行，當同時執行的critical section數目大於&lt;code&gt;S&lt;/code&gt;時，會被停下來，等待到同時執行的critical section小於S時，才能繼續搶進去執行。&lt;/p&gt;
&lt;p&gt;如果要用mutex lock的方式執行，會讓很多process一直在執行loop，對於資源的浪費太大了，所以在semaphore lock的時候，會採用將process 暫停，將address存到lock &lt;code&gt;S&lt;/code&gt; 的list裡面。等到有process把&lt;code&gt;S&lt;/code&gt;給釋放，此時CPU會將S裡面的list，取出一個process出來執行。&lt;/p&gt;
&lt;h2 id=&#34;我混淆的概念釐清&#34;&gt;我混淆的概念釐清
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;鎖不是鎖住cpu，而是鎖住其他一樣需要這個鎖的process，讓同一個鎖保護的同一個（或者不同個）critical section ，一次最多只能有1（或者semaphore lock設定的數字）個process存取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被鎖保護住的critical section，只要裡面有存取某個共用資源的code，就能讓這項資源被鎖給保護，不被濫用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;p&gt;鎖的概念就是為了要保護有限的資源，不要被無限的取用。例如可以利用鎖來保護對同一個檔案的更改，讓這個檔案一次只能被一個process更新，防止檔案內資料變得亂七八糟的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>資料庫的同步</title>
        <link>http://coding.fnsne.com/posts/2022-09-14/%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</link>
        <pubDate>Wed, 14 Sep 2022 16:22:17 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-09-14/%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E5%90%8C%E6%AD%A5/</guid>
        <description>&lt;h2 id=&#34;網路上查到簡單說明transaction的例子常常都是用轉賬來說明但其實還有很多東西需要注意&#34;&gt;網路上查到簡單說明transaction的例子，常常都是用轉賬來說明，但其實還有很多東西需要注意
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;帳戶轉賬，因為race condition的緣故，導致操作欄位的值被改錯。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A有100，B有40。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A轉100元給B，B轉20元給A，由兩個不同的client來處理操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;順序正確時：A會是減掉80&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是當順序不正確，則數字會錯掉，例如A很早取得現在的餘額（100），但是更新數字0慢了，導致A最終變成0元，因為在B轉完帳後才更新值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上的這個問題很明顯的是race condition。所謂的race condition是結果必須依賴與某種特定的順序，但是順序又並不是固定的，因此偶爾會出現錯誤。&lt;/p&gt;
&lt;h2 id=&#34;解決race-condition的方法&#34;&gt;解決race condition的方法
&lt;/h2&gt;&lt;p&gt;為了要解決race condition，必須得要讓操作依照我們期望的順序才操作，才能預防不對的順序導致的錯誤。為了要達到這個目標，資料庫本身有提供兩種方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;atomic update：資料庫提供的一個，對於單一欄位數值做相依於原本值的操作指令。這個操作過程會是atomic的，也就是不會操作到一半值被改掉而導致結果出錯。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt; products &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; quantity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; quantity &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;優點：因為只是對於欄位做簡單的數字運算並馬上更新上去，所以對於欄位的佔用時間相較下面的select for update較短，且資料庫會將這類atomic操作做優化，所以效能會比較好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺點：只支援對於數值的簡單操作後更新，並不能做太複雜的運算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;select for update：這個操作被限制在transaction開起來的時候才能使用，使用時實際上就是將指定的欄位上一個更新的lock，此時直到commit之前，沒有其他client可以對這個欄位做任何更新。所以就能夠限制欄位更新的順序了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Begin&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; quantity &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;q &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; products &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt; products &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; quantity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;$&lt;/span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;Commit&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;優點：因為有上鎖了，所以幾乎可以用各種邏輯運算來更新欄位的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺點：因為會在欄位上面上鎖，並且持續到commit位置，所以對於效能會有很大的影響。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;version scheme ：在table上面多新增一個欄位叫做version，來確定現在更新時的version，是否從拿值的時候到現在還沒有被更新過。程式可以藉由資料庫回傳的訊息，&lt;code&gt;是否有更改到任何row&lt;/code&gt;來判斷是否更新成功。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;old_ver &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; money, &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; bank &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;update&lt;/span&gt; bank &lt;span style=&#34;color:#66d9ef&#34;&gt;set&lt;/span&gt; money &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt; name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A &lt;span style=&#34;color:#66d9ef&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;version&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; old_ver&lt;span style=&#34;color:#f92672&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;優點：能夠不使用任何鎖的時候實現。（或者還有其他我想不到的優點）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺點：可能會很浪費時間，尤其是當更新的頻率特別高的時候，可能很難可以得到把值更新下去的機會。並且失敗後得要重頭來過。可能會造成鎖的飢餓效應。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;一開始提到的例子裡面真正用到transaction功能的地方&#34;&gt;一開始提到的例子裡面真正用到transaction功能的地方
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用transaction遇到錯誤時會rollback的特性，來在餘額小於0的時候，復原到還未轉賬之前的狀態。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何檢查餘額小於0，並在此時丟出錯誤呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用select for update鎖住欄位更新，在此時檢查，通過且做完操作後commit，釋放鎖。就可以避免此時有其他操作更動到這個帳戶的餘額。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;優點：可以實作各種複雜的檢查邏輯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺點：必須為這個帳戶的餘額上鎖，此時沒有其他人可以操作（也就是沒有其他人可以轉賬給他、領錢等操作），會導致效能低下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/21503658/prevent-less-than-zero-values-in-postgresql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;check constraint&lt;/a&gt; 來讓資料庫在欄位不符合規範的時候丟出錯誤。此時就可以配合transaction來rollback復原了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;優點：因為check constraint是資料庫提供可以給欄位增加規範的設定，檢查會在更新的時候做，所以即使背後有使用鎖，所花費的時間會比用select for update還要少。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺點：只能依照資料庫提供的有限constraint來設定，並不一定能夠做到想要的規範。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;遇到需要注意順序的操作，先試著能不能使用atomic update的方式來完成需求，沒有辦法的時候才會使用select for update的方式來限制進到這個transaction後，必須要操作完這邊的指令後，才能換別人改值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遇到需要檢查數值符不符合規範，先試著用check constraint來限制欄位，真的沒有辦法，才會採用select for update的方式來將欄位上鎖，來做檢查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考資料&#34;&gt;參考資料
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/interviewnoodle/how-to-avoid-the-race-condition-and-the-negative-value-3f397b2b08e4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;How to avoid the race condition and the negative value&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/21503658/prevent-less-than-zero-values-in-postgresql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;check constraint&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/143866444&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;select for update 詳解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/21503658/prevent-less-than-zero-values-in-postgresql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;check constraint&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>我用heptabase來實作卡片盒筆記的方式</title>
        <link>http://coding.fnsne.com/posts/2022-09-03/heptabase-zettelkasten/</link>
        <pubDate>Sat, 03 Sep 2022 23:18:17 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-09-03/heptabase-zettelkasten/</guid>
        <description>&lt;h2 id=&#34;卡片盒筆記寫作有兩種方式&#34;&gt;卡片盒筆記寫作有兩種方式
&lt;/h2&gt;&lt;p&gt;卡片盒筆記的做法，現在網路上很多影片、文章都有教了，所以我就不贅述了，這篇文章主要是記錄我如何在heptabase上面實作卡片盒筆記的方式。目前理解到的用法大致上有兩種方式。&lt;/p&gt;
&lt;h3 id=&#34;闡述延伸自己論點的做法&#34;&gt;闡述延伸自己論點的做法
&lt;/h3&gt;&lt;p&gt;google搜尋卡片盒筆記最容易找到的是閱讀前哨戰站長瓦基的文章，張永錫老師有一次有和瓦基、朱騏有&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v%5c=TtuufXfSkXU&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;直播&lt;/a&gt; ，我在這邊大概知道了瓦基使用heptabase的方式 ，大致上就是持續將相同大分類（同board）的卡片做&lt;code&gt;多張卡片凝聚出共通點&lt;/code&gt;、&lt;code&gt;複雜卡片切割成多張不需要上下文即可理解的論述&lt;/code&gt;、&lt;code&gt;依照因果關係或層級架構為卡片作出連結&lt;/code&gt;。最後依照這個的架構輸出成文章。&lt;a class=&#34;link&#34; href=&#34;https://readingoutpost.com/zettelkasten-6-steps/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;瓦基卡片盒筆記的文章&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;不同卡片蹦發出新的東西&#34;&gt;不同卡片蹦發出新的東西
&lt;/h3&gt;&lt;p&gt;在&lt;a class=&#34;link&#34; href=&#34;https://hahow.in/courses/623156dc32edfc0007190299/main&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;張永錫老師在hahow的卡片盒筆記術&lt;/a&gt; 中，教導的寫文章方式，則是直接將所有搜尋到有所關聯的卡片複製到&lt;a class=&#34;link&#34; href=&#34;http://whimsical.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;whimsical&lt;/a&gt;上面，再來整理排序，變成一張完整的文章。&lt;/p&gt;
&lt;h2 id=&#34;對我來說&#34;&gt;對我來說
&lt;/h2&gt;&lt;p&gt;我使用卡片盒筆記的目的是學習知識、整理思路，對於&lt;a class=&#34;link&#34; href=&#34;https://hahow.in/courses/623156dc32edfc0007190299/main&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;卡片盒筆記術課程&lt;/a&gt;中教導的用&lt;a class=&#34;link&#34; href=&#34;http://whimsical.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;whimsical&lt;/a&gt; 配合notion放卡片，對於長期的專案來說，持續分裂、內聚的卡片很難同步。我的結論是，這套流程只比較適合一次結束的專案。&lt;/p&gt;
&lt;p&gt;所以在理清&lt;code&gt;我需要讓專案持續成長，又要能夠視覺化看到因果和層級架構&lt;/code&gt; 這件事後，我馬上就花錢訂閱了heptabase。&lt;/p&gt;
&lt;h2 id=&#34;我實際的做法&#34;&gt;我實際的做法
&lt;/h2&gt;&lt;h3 id=&#34;整理卡片收集整理材料&#34;&gt;整理卡片（收集、整理材料）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;white board為一項大項知識的庫，在裡面可以持續新增卡片，並且整理出順序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;持續做以下的流程&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;為簡單的卡片查詢資料&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;將資料整理成多項能夠獨立闡述內容的卡片（永久卡片）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看看多張卡片可不可以凝聚出共同性，將其抽出來寫成卡片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;看看有沒有卡片寫了太多項內容，將內容封裝成多張卡片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果卡片之間有因果關係、架構層級，為其加上connection。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;在這邊要注意一點是，link和connection感覺很相似，我剛開始很混亂，不知道要怎麼使用。因為同時想要能&lt;a class=&#34;link&#34; href=&#34;#%E9%97%A1%E8%BF%B0%E5%BB%B6%E4%BC%B8%E8%87%AA%E5%B7%B1%E8%AB%96%E9%BB%9E%E7%9A%84%E5%81%9A%E6%B3%95&#34; &gt;闡述延伸自己論點的做法&lt;/a&gt; 、&lt;a class=&#34;link&#34; href=&#34;#%E4%B8%8D%E5%90%8C%E5%8D%A1%E7%89%87%E8%B9%A6%E7%99%BC%E5%87%BA%E6%96%B0%E7%9A%84%E6%9D%B1%E8%A5%BF&#34; &gt;不同卡片蹦發出新的東西&lt;/a&gt; ，所以會想要讓所有卡片之間的關聯都是用connection來連結。但是這個做法會讓畫面變得很混亂，反而會阻礙思考。後來在釐清了我使用卡片筆記的主要用法是&lt;a class=&#34;link&#34; href=&#34;#%E9%97%A1%E8%BF%B0%E5%BB%B6%E4%BC%B8%E8%87%AA%E5%B7%B1%E8%AB%96%E9%BB%9E%E7%9A%84%E5%81%9A%E6%B3%95&#34; &gt;闡述延伸自己論點的做法&lt;/a&gt; 後，就決定只讓有因係、層級架構關聯的卡片，使用connection，而其他的關聯則是在卡片內文使用link的方式來關聯。這個是在直播裡面學到的&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?t%5C%5c=2672&amp;amp;v%5c=TtuufXfSkXU&amp;amp;feature%5c=youtu.be&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;瓦基使用link和connect的時機&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;寫成文章時&#34;&gt;寫成文章時
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;把所有想到和這篇文章相關的卡片用bullet list 來link到entry card&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;這個方法是從瓦基學到的，文章/keyword card/entry卡片上面先用link把所有相關的卡片給連結進來。再來在這張卡片下面開始書寫文章。&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-03/heptabase-zettelkasten/keyword-card.png&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;entry card&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;這個方法的完全是利用了heptabase的功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先heptabase的list可以隨意拖拉，來初步排列出書寫的順序。這個在各大筆記軟體（notion、evernote等）上的bullet list 其實都可以做得到。
&lt;figure&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/oR_Vovjx-cbE9xENfmEpSMzZ35_6DC-_K5kTYVO9WHkiJaHMz0QRpg0me-2dXTrh3Hg0NCARJmJAiIoPjEqEOO9unp_ItgyASM6NQ-Ao_DgT2Hg58W2L0-uogI-Sybf1B36gsw-rzx4=w2400&#34;&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Open in new tab → 再點選所有的link，heptabase會在右邊打開所有卡片，這樣可以快速的複製卡片內容過來變成初稿。
&lt;figure&gt;&lt;img src=&#34;https://lh3.googleusercontent.com/EKz6pTXK0nYgLOuf0DSspDZxVUL-kX7Ql7x8AeaUrSBz4bpbi9ADa-Uu1sgPtsSDS7iDDthbjz1Jt8t7hq7fTfI0H7YtDZj9d5SgPAvd30j_niOwIwQJC5zblwlC-mmCbEcufSQ_xIY=w2400&#34;&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這篇文章大致上描述了我現在會在heptabase上面實作的卡片筆記流程，並且這篇文章也是我第一次在heptabase上面使用卡片筆記寫成的。總共花了一個下午和半個晚上研究、半個晚上整理成文章。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Hugo LoveIt 不會顯示toc</title>
        <link>http://coding.fnsne.com/posts/2022-09-02/hugo-loveit-%E4%B8%8D%E6%9C%83%E9%A1%AF%E7%A4%BA/</link>
        <pubDate>Fri, 02 Sep 2022 16:06:28 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-09-02/hugo-loveit-%E4%B8%8D%E6%9C%83%E9%A1%AF%E7%A4%BA/</guid>
        <description>&lt;h1 id=&#34;問題描述&#34;&gt;問題描述
&lt;/h1&gt;&lt;p&gt;明明有開啟toc功能，但是在旁邊的toc卻完全沒有顯示任何的標題鏈接。&lt;/p&gt;
&lt;h1 id=&#34;解法&#34;&gt;解法
&lt;/h1&gt;&lt;p&gt;這個問題的原因很簡單，是因為LoveIt預設會抓h2的標題，但我習慣從h1的標題開始寫，所以在toc上面沒有任何的標題存在。&lt;/p&gt;
&lt;p&gt;解決的方法很簡單，只要到設定（&lt;code&gt;config.toml&lt;/code&gt;）裡面，加上&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[markup]
  [markup.tableOfContents]
    startLevel = 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即可讓LoveIt從h1就開始抓到toc上面。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;reference
&lt;/h1&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/dillonzq/LoveIt/issues/410#issuecomment-647272066&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LoveIt Github Issue 410&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Hugo  Bundle問題</title>
        <link>http://coding.fnsne.com/posts/2022-09-02/hugo-bundle%E5%95%8F%E9%A1%8C/</link>
        <pubDate>Fri, 02 Sep 2022 14:36:26 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-09-02/hugo-bundle%E5%95%8F%E9%A1%8C/</guid>
        <description>&lt;h1 id=&#34;描述&#34;&gt;描述
&lt;/h1&gt;&lt;p&gt;原本在hugo上面放文章是把所有的文章和圖片都放在&lt;code&gt;content/posts/&lt;/code&gt;裡面用文章來分類。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;content/posts/
├── post1
│    └── post1.md
│    └── img1.jpg   
├── post2
│    └── post2.md
│    └── img2.jpg   
├── post3
│    └── post3.md
│    └── img3.jpg   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因為覺得全部文章和圖片都放在一起是在是太過於雜亂，而且害怕未來文章多的時候，markdown和圖片的命名會很痛苦，雖然也是可以利用在前面加上日期前綴來區分，但感覺還是會很亂。所以開始研究page bundle怎麼處理,試著將結構改成這樣。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;content/posts/
├── 2022-08-02
│   └── post1         
│       └── post1.md
│       └── img1.jpg   
│   └── post2         
│       └── post2.md
│       └── img2.jpg   
├── 2022-09-02
│   └── post3         
│       └── post3.md
│       └── img3.jpg   
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;問題&#34;&gt;問題
&lt;/h1&gt;&lt;p&gt;看到跑出來的網頁上，載入圖片404的網址居然是還會增加一個文章名稱的資料夾，然後才存取圖片。以上面的例子來看， 打開網頁 post1頁面，網址會是&lt;code&gt;domain/posts/2022-08-02/post1/post1/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而圖片是呼叫&lt;code&gt;domain/posts/2022-08-02/post1/post1/img1.jpg&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可是實際上到build出來的public裡面去看，這一個頁面的結構居然是長這樣&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;├── 2022-08-02
│   └── post1         
│       └── post1.md
│       └── img1.jpg   
│       └── post1         
│           └── index.html         
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;解法&#34;&gt;解法
&lt;/h1&gt;&lt;p&gt;因為查到的所有資料，上面寫的md都命名為&lt;code&gt;index&lt;/code&gt;，所以試著把&lt;code&gt;post1.md&lt;/code&gt;改名為&lt;code&gt;index.md&lt;/code&gt;，一切就正常了，而此時&lt;code&gt;public&lt;/code&gt;裡面的資料結構變成長這樣。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;├── 2022-08-02
│   └── post1         
│       └── post1.md
│       └── img1.jpg   
│       └── index.html         
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起來可能是因為bundle是抓&lt;code&gt;index.md&lt;/code&gt;這個關鍵字的來製作頁面，如果沒有這個檔案，會用現有的&lt;code&gt;*.md&lt;/code&gt;的檔案，各自建立一個它名稱的資料夾，然後在裡面建立index.html。所以原本的做法才會長成奇怪的結構。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;reference
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/gohugoio/hugo/issues/1240&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hugo github上面討論bundle的issue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.darkthread.net/blog/hugo-figures/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Markdown 技術文件寫作-處理圖檔&amp;mdash;黑暗執行續&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/content-management/page-bundles/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hugo官網 Page Bundle&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Goland Markdown split editor消失的問題</title>
        <link>http://coding.fnsne.com/posts/2022-09-01/goland-markdown-split-editor%E6%B6%88%E5%A4%B1%E7%9A%84%E5%95%8F%E9%A1%8C/</link>
        <pubDate>Thu, 01 Sep 2022 20:21:30 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-09-01/goland-markdown-split-editor%E6%B6%88%E5%A4%B1%E7%9A%84%E5%95%8F%E9%A1%8C/</guid>
        <description>&lt;p&gt;最近開始使用Goland來用hugo寫部落格文章，之前markdown的preview分頁都還很正常，但到了今天，突然之間只剩下一般的編輯界面，而且Goland好像還把它識別為html,旁邊會出現在各種瀏覽器上面的按鈕。
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-01/goland-markdown-split-editor%E6%B6%88%E5%A4%B1%E7%9A%84%E5%95%8F%E9%A1%8C/2022-09-01-markdown_detected_wrong.jpg&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;偵測成html&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;而且使用hugo的shortcode還會出現網頁相關的錯誤訊息，在設定裡面查了一陣子才發現到。關於檔案的偵測少了&lt;code&gt;.md&lt;/code&gt;的部分，只剩下&lt;code&gt;markdown&lt;/code&gt;的部分
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-01/goland-markdown-split-editor%E6%B6%88%E5%A4%B1%E7%9A%84%E5%95%8F%E9%A1%8C/2022-09-01-fileTypeMarkDownSetting.jpg&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;settings -&amp;gt; Editor -&amp;gt; File Type&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;將&lt;code&gt;*.md&lt;/code&gt;加上去，一切的紅底線、還有markdown就都全部回來了。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>CloudFlare SSL in redirect loop</title>
        <link>http://coding.fnsne.com/posts/2022-09-01/cloudflare_ssl_in_redirect_loop/</link>
        <pubDate>Thu, 01 Sep 2022 17:01:39 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-09-01/cloudflare_ssl_in_redirect_loop/</guid>
        <description>&lt;h1 id=&#34;內文&#34;&gt;內文
&lt;/h1&gt;&lt;p&gt;最近在godaddy上面購買網域，然後使用cloudflare來申請ssl並弄成https的連線。結果今天上來看blog卻發現進不去，錯誤訊息是太多的redirect了。
打開F12重整看看，還真的是持續進行著
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-01/cloudflare_ssl_in_redirect_loop/2022-09-01-repeat301.jpg&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;重複redirect到首頁的情況&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;經過一段研究，發現只是這個問題很sssssssss多人有遇到，只是因為CloudFlare的SSL設定設到了Flexible&lt;/p&gt;
&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-01/cloudflare_ssl_in_redirect_loop/2022-09-01-wrongSSL_setting.jpg&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;造成迴圈的ssl設定&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;figure&gt;&lt;img src=&#34;http://coding.fnsne.com/posts/2022-09-01/cloudflare_ssl_in_redirect_loop/2022-09-01-rightSSL-setting.jpg&#34;&gt;&lt;figcaption&gt;
      &lt;h4&gt;正確的設定&lt;/h4&gt;
    &lt;/figcaption&gt;
&lt;/figure&gt;

&lt;h1 id=&#34;參考資料&#34;&gt;參考資料
&lt;/h1&gt;&lt;p&gt;{&amp;lt; link &amp;ldquo;&lt;a class=&#34;link&#34; href=&#34;https://community.cloudflare.com/t/error-301-on-dns-and-http-proxy/77699%22&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://community.cloudflare.com/t/error-301-on-dns-and-http-proxy/77699&#34;&lt;/a&gt; &amp;gt;}}&lt;/p&gt;
</description>
        </item>
        <item>
        <title>About Me</title>
        <link>http://coding.fnsne.com/page/about/</link>
        <pubDate>Tue, 30 Aug 2022 22:46:18 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/page/about/</guid>
        <description>&lt;p&gt;2023~ BigObject 後端工程師&lt;br&gt;
2018-2022 擔任CAPSULE後端工程師&lt;/p&gt;
</description>
        </item>
        <item>
        <title>淺談在Golang上面的物件導向</title>
        <link>http://coding.fnsne.com/posts/2022-08-02/%E6%B7%BA%E8%AB%87%E5%9C%A8golang%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91/</link>
        <pubDate>Tue, 02 Aug 2022 20:01:59 +0800</pubDate>
        
        <guid>http://coding.fnsne.com/posts/2022-08-02/%E6%B7%BA%E8%AB%87%E5%9C%A8golang%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91/</guid>
        <description>&lt;p&gt;從物件導向的語言轉到Golang常常會遇到，不知道該怎麼在Golang實作類似多型和繼承的功能。這是因為Golang根本不是物件導向的語言。&lt;/p&gt;
&lt;p&gt;在網路上會看到一些文章，寫說可以使用可以embed來模擬繼承，但事實上embed的用途應該只是用來減少重複的程式碼，增加可讀性。像在io package裡面就很明顯，如interface ReadWriter就是用Reader和Writer 兩個interface組合起來的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReadWriter&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Reader&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;Writer&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用embed struct的方式來模擬繼承。為了要可以被抽換注入，還是得要同時implement一個interface。這樣還不如直接implement interface就好了。&lt;/p&gt;
&lt;p&gt;在Golang，唯一類似物件導向的東西只有 interface。只要有implement interface，就可以在宣告使用這個interface的地方使用。&lt;/p&gt;
&lt;p&gt;個人的理解，Golang把繼承的概念且分成兩個部分：embed和interface。embed struct (interface) 負責擴增fields (method); interface負責讓不同struct可以有相同的調用方式&lt;/p&gt;
&lt;p&gt;embed struct 的功能只是單純消除struct的field的重用而已。embed interface 也是如此，單純想要減少 method 裡面重複宣告 method 的程式碼。&lt;/p&gt;
&lt;p&gt;簡單來說，就是&lt;/p&gt;
&lt;p&gt;想要可以抽換，用interface; 想要減少重複可以用embed的方式包裝組合&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Search</title>
        <link>http://coding.fnsne.com/page/search/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://coding.fnsne.com/page/search/</guid>
        <description></description>
        </item>
        
    </channel>
</rss>
