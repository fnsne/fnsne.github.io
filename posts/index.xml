<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - fnsne&#39;s coding world</title>
        <link>http://coding.fnsne.com/posts/</link>
        <description>All Posts | fnsne&#39;s coding world</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-TW</language><managingEditor>watashiwafnsne@gmail.com (fnsne)</managingEditor>
            <webMaster>watashiwafnsne@gmail.com (fnsne)</webMaster><lastBuildDate>Fri, 02 Sep 2022 16:06:28 &#43;0800</lastBuildDate><atom:link href="http://coding.fnsne.com/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Hugo LoveIt 不會顯示toc</title>
    <link>http://coding.fnsne.com/posts/2022-09-02/hugo-loveit-%E4%B8%8D%E6%9C%83%E9%A1%AF%E7%A4%BA/</link>
    <pubDate>Fri, 02 Sep 2022 16:06:28 &#43;0800</pubDate>
    <author>fnsne</author>
    <guid>http://coding.fnsne.com/posts/2022-09-02/hugo-loveit-%E4%B8%8D%E6%9C%83%E9%A1%AF%E7%A4%BA/</guid>
    <description><![CDATA[問題描述 明明有開啟toc功能，但是在旁邊的toc卻完全沒有顯示任何的標題鏈接。
解法 這個問題的原因很簡單，是因為LoveIt預設會抓h2的標題，但我習慣從h1的標題開始寫，所以在toc上面沒有任何的標題存在。
解決的方法很簡單，只要到設定（config.toml）裡面，加上
1 2 3 [markup] [markup.tableOfContents] startLevel = 1 即可讓LoveIt從h1就開始抓到toc上面。
reference LoveIt Github Issue 410 ]]></description>
</item>
<item>
    <title>Hugo  Bundle問題</title>
    <link>http://coding.fnsne.com/posts/2022-09-02/hugo-bundle%E5%95%8F%E9%A1%8C/</link>
    <pubDate>Fri, 02 Sep 2022 14:36:26 &#43;0800</pubDate>
    <author>fnsne</author>
    <guid>http://coding.fnsne.com/posts/2022-09-02/hugo-bundle%E5%95%8F%E9%A1%8C/</guid>
    <description><![CDATA[描述 原本在hugo上面放文章是把所有的文章和圖片都放在content/posts/裡面用文章來分類。
1 2 3 4 5 6 7 8 9 10 content/posts/ ├── post1 │ └── post1.md │ └── img1.jpg ├── post2 │ └── post2.md │ └── img2.jpg ├── post3 │ └── post3.md │ └── img3.jpg 因為覺得全部文章和圖片都放在一起是在是太過於雜亂，而且害怕未來文章多的時候，markdown和圖片的命名會很痛苦，雖然也是可以利用在前面加上日期前綴來區分，但感覺還是會很亂。所以開始研究page bundle怎麼處理,試著將結構改成這樣。
1 2 3 4 5 6 7 8 9 10 11 12 content/posts/ ├── 2022-08-02 │ └── post1 │ └── post1.md │ └── img1.jpg │ └── post2 │ └── post2.md │ └── img2.]]></description>
</item>
<item>
    <title>Goland Markdown split editor消失的問題</title>
    <link>http://coding.fnsne.com/posts/2022-09-01/goland-markdown-split-editor%E6%B6%88%E5%A4%B1%E7%9A%84%E5%95%8F%E9%A1%8C/</link>
    <pubDate>Thu, 01 Sep 2022 20:21:30 &#43;0800</pubDate>
    <author>fnsne</author>
    <guid>http://coding.fnsne.com/posts/2022-09-01/goland-markdown-split-editor%E6%B6%88%E5%A4%B1%E7%9A%84%E5%95%8F%E9%A1%8C/</guid>
    <description><![CDATA[最近開始使用Goland來用hugo寫部落格文章，之前markdown的preview分頁都還很正常，但到了今天，突然之間只剩下一般的編輯界面，而且Goland好像還把它識別為html,旁邊會出現在各種瀏覽器上面的按鈕。 偵測成html 而且使用hugo的shortcode還會出現網頁相關的錯誤訊息，在設定裡面查了一陣子才發現到。關於檔案的偵測少了.md的部分，只剩下markdown的部分 settings -&gt; Editor -&gt; File Type 將*.md加上去，一切的紅底線、還有markdown就都全部回來了。]]></description>
</item>
<item>
    <title>CloudFlare SSL in redirect loop</title>
    <link>http://coding.fnsne.com/posts/2022-09-01/cloudflare_ssl_in_redirect_loop/</link>
    <pubDate>Thu, 01 Sep 2022 17:01:39 &#43;0800</pubDate>
    <author>fnsne</author>
    <guid>http://coding.fnsne.com/posts/2022-09-01/cloudflare_ssl_in_redirect_loop/</guid>
    <description><![CDATA[內文 最近在godaddy上面購買網域，然後使用cloudflare來申請ssl並弄成https的連線。結果今天上來看blog卻發現進不去，錯誤訊息是太多的redirect了。 打開F12重整看看，還真的是持續進行著 重複redirect到首頁的情況 經過一段研究，發現只是這個問題很多人有遇到，只是因為CloudFlare的SSL設定設到了Flexible
造成迴圈的ssl設定 正確的設定 參考資料 https://community.cloudflare.com/t/error-301-on-dns-and-http-proxy/77699 ]]></description>
</item>
<item>
    <title>淺談在Golang上面的物件導向</title>
    <link>http://coding.fnsne.com/posts/2022-08-02/%E6%B7%BA%E8%AB%87%E5%9C%A8golang%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91/</link>
    <pubDate>Tue, 02 Aug 2022 20:01:59 &#43;0800</pubDate>
    <author>fnsne</author>
    <guid>http://coding.fnsne.com/posts/2022-08-02/%E6%B7%BA%E8%AB%87%E5%9C%A8golang%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91/</guid>
    <description><![CDATA[從物件導向的語言轉到Golang常常會遇到，不知道該怎麼在Golang實作類似多型和繼承的功能。這是因為Golang根本不是物件導向的語言。
在網路上會看到一些文章，寫說可以使用可以embed來模擬繼承，但事實上embed的用途應該只是用來減少重複的程式碼，增加可讀性。像在io package裡面就很明顯，如interface ReadWriter就是用Reader和Writer 兩個interface組合起來的。
1 2 3 4 type ReadWriter interface { Reader Writer } 使用embed struct的方式來模擬繼承。為了要可以被抽換注入，還是得要同時implement一個interface。這樣還不如直接implement interface就好了。
在Golang，唯一類似物件導向的東西只有 interface。只要有implement interface，就可以在宣告使用這個interface的地方使用。
個人的理解，Golang把繼承的概念且分成兩個部分：embed和interface。embed struct (interface) 負責擴增fields (method); interface負責讓不同struct可以有相同的調用方式
embed struct 的功能只是單純消除struct的field的重用而已。embed interface 也是如此，單純想要減少 method 裡面重複宣告 method 的程式碼。
簡單來說，就是
想要可以抽換，用interface; 想要減少重複可以用embed的方式包裝組合]]></description>
</item>
</channel>
</rss>
